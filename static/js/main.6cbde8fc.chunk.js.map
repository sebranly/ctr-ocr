{"version":3,"sources":["types.ts","utils/index.ts","constants.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["Category","getCloserString","str","list","listSafe","filter","s","min","Infinity","name","forEach","lev","levenshtein","get","getExtract","info","index","category","width","height","left","applyRatio","top","widthCrop","heightCrop","All","ratioHeight","CTR_MAX_PLAYERS","extract","ratioTime","ratioEnd","ratioLeftOffsetName","ratioEndPosition","antiRatioTime","rectangle","topExt","heightExt","Position","leftExtTime","widthExtTime","leftExtName","widthExtName","isTime","Time","leftExt","widthExt","numberRange","max","numbers","i","push","getParams","Username","tessedit_char_whitelist","CHARLIST_POSITION","tessedit_pageseg_mode","PSM_SINGLE_CHAR","CHARLIST_USERNAME","PSM_SINGLE_LINE","CHARLIST_TIME","ratio","nb","Math","floor","charRange","startChar","stopChar","startInt","charCodeAt","stopInt","result","String","fromCharCode","CHARLIST_UPPERCASE_LETTERS","join","CHARLIST_LOWERCASE_LETTERS","CHARLIST_LETTERS","CHARLIST_DIGITS","App","renderDot","classColorSuffix","step","classColor","classes","key","className","renderBody","resultsOcr","map","rawLine","position","username","time","onMount","a","setOnMountOver","setSelectIsDisabled","doOCR","onMountOver","setStep","setResultsOcr","undefined","schedulerUsername","createScheduler","workerUsername","createWorker","addWorker","div","document","getElementsByClassName","innerHTML","setOcr","load","loadLanguage","initialize","usernameParams","setParameters","playerIndexes","nbPlayers","promisesX","playerIndex","imgTrans","imgTransCopy","clone","scheduler","dimensions","extracted","crop","options","count","type","getBufferAsync","buffer","getColors","then","colors","rgb","shouldInvert","extractedFin","invert","bufferFin","addJob","pathInput","imgIndex","Jimp","read","imgJimp","rotate","w","bitmap","h","dimensionsCrop","getBase64","err","src","img","createElement","setAttribute","appendChild","promisesNames","grayscale","Promise","all","results","resultsNames","r","data","text","replace","referencePlayers","players","split","playerGuess","d","terminate","toString","useWindowSize","React","ocr","setNbPlayers","selectIsDisabled","setImgIndex","setPlayers","optionsNbPlayers","classPlatform","isMobile","rel","href","numberOfPieces","recycle","onChange","e","Number","target","value","option","label","placeholder","rows","currentTarget","disabled","onClick","id","alt","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.6cbde8fc.chunk.js","sourcesContent":["export enum Category {\n  Position = 'position',\n  Time = 'time',\n  Username = 'username',\n  All = 'all'\n}\n\nexport type Validation = {\n  correct: boolean;\n  errMsg: string;\n};\n\nexport type Coord = {\n  height: number;\n  left: number;\n  top: number;\n  width: number;\n};\n","import levenshtein from 'fast-levenshtein';\nimport {\n  CHARLIST_POSITION,\n  CHARLIST_TIME,\n  CHARLIST_USERNAME,\n  CTR_MAX_PLAYERS,\n  CTR_MAX_TIME_DIFF_SEC,\n  PSM_SINGLE_CHAR,\n  PSM_SINGLE_LINE,\n  TIME_DNF\n} from '../constants';\nimport { Category, Coord, Validation } from '../types';\nimport { REGEX_TIME } from './regEx';\nimport { uniq } from 'lodash';\n\nconst cleanString = (str: string) => str.replace(/\\n/g, '').replace(/ /g, '');\n\nconst positionIsValid = (position: string, max: number) => {\n  if (!position) return false;\n  const pos = Number(position);\n  const isValid = position.length === 1 && pos >= 1 && pos <= max;\n\n  return isValid;\n};\n\nconst convertToMs = (time: string) => {\n  const timeIsValid = REGEX_TIME.test(time);\n  if (!timeIsValid) return 0;\n\n  const splits = time.split(':');\n  if (splits.length < 3) return 0;\n  const [minutesStr, secondsStr, centisecondsStr] = splits;\n\n  const minutes = Number(minutesStr);\n  const seconds = Number(secondsStr);\n  const centiseconds = Number(centisecondsStr);\n\n  const milliseconds = centiseconds * 10 + seconds * 1000 + minutes * 60 * 1000;\n\n  return milliseconds;\n};\n\nconst getCloserString = (str: string, list: string[]) => {\n  const listSafe = list.filter((s: string) => !!s);\n  let min = Infinity;\n  let name = str;\n\n  listSafe.forEach((s: string) => {\n    const lev = levenshtein.get(str, s);\n\n    if (lev < min) {\n      min = lev;\n      name = s;\n    }\n  });\n\n  return name;\n};\n\n// TODO: for All, index is actually the number of players\nconst getExtract = (info: any, index = 0, category: Category) => {\n  const { width, height } = info;\n  const left = applyRatio(0.64, width);\n  const top = applyRatio(0.265, height);\n  const widthCrop = applyRatio(0.27, width);\n  const heightCrop = applyRatio(0.425, height);\n\n  if (category === Category.All) {\n    const ratioHeight = index / CTR_MAX_PLAYERS;\n    const extract: Coord = {\n      height: applyRatio(ratioHeight, heightCrop),\n      left,\n      top,\n      width: widthCrop\n    };\n\n    return extract;\n  }\n\n  const ratioTime = 0.73;\n  const ratioEnd = 0.03;\n  const ratioLeftOffsetName = 0.27;\n  const ratioEndPosition = 0.1;\n  const antiRatioTime = 1 - ratioTime - ratioEnd;\n\n  const rectangle = {\n    top: applyRatio(index / 8, heightCrop),\n    height: applyRatio(1 / 8, heightCrop)\n  };\n\n  const topExt = top + rectangle.top;\n  const heightExt = rectangle.height;\n\n  if (category === Category.Position) {\n    const extract: Coord = {\n      height: heightExt,\n      left: left,\n      top: topExt,\n      width: applyRatio(ratioEndPosition, widthCrop)\n    };\n\n    return extract;\n  }\n\n  const leftExtTime = left + applyRatio(ratioTime, widthCrop);\n  const widthExtTime = applyRatio(antiRatioTime, widthCrop);\n\n  const leftExtName = left + applyRatio(ratioLeftOffsetName, widthCrop);\n  const widthExtName = applyRatio(1 - antiRatioTime - ratioLeftOffsetName - ratioEnd, widthCrop);\n\n  const isTime = category === Category.Time;\n  const leftExt = isTime ? leftExtTime : leftExtName;\n  const widthExt = isTime ? widthExtTime : widthExtName;\n\n  const extract: Coord = {\n    height: heightExt,\n    left: leftExt,\n    top: topExt,\n    width: widthExt\n  };\n\n  return extract;\n};\n\nconst numberRange = (min: number, max: number) => {\n  const numbers = [];\n  for (let i = min; i <= max; i += 1) numbers.push(i);\n  return numbers;\n};\n\nconst getParams = (category: Category) => {\n  const { Position, Time, Username } = Category;\n\n  switch (category) {\n    case Position:\n      return {\n        tessedit_char_whitelist: CHARLIST_POSITION,\n        tessedit_pageseg_mode: PSM_SINGLE_CHAR as any\n      };\n\n    case Username:\n      return {\n        tessedit_char_whitelist: CHARLIST_USERNAME,\n        tessedit_pageseg_mode: PSM_SINGLE_LINE as any\n      };\n\n    case Time:\n    default:\n      return {\n        tessedit_char_whitelist: CHARLIST_TIME,\n        tessedit_pageseg_mode: PSM_SINGLE_LINE as any\n      };\n  }\n};\n\nconst applyRatio = (ratio: number, nb: number) => Math.floor(ratio * nb);\n\nconst charRange = (startChar: string, stopChar: string) => {\n  const startInt = startChar.charCodeAt(0);\n  const stopInt = stopChar.charCodeAt(0);\n  const result = [];\n\n  for (let i = startInt; i <= stopInt; i += 1) {\n    result.push(String.fromCharCode(i));\n  }\n\n  return result;\n};\n\nconst validateUsernames = (usernames: string[]) => {\n  const validation: Validation = {\n    correct: false,\n    errMsg: ''\n  };\n\n  const empty = usernames.some((str: string) => !str);\n  if (empty) {\n    validation.errMsg = 'At least one username is missing';\n\n    return validation;\n  }\n\n  const uniqueUsernames = uniq(usernames);\n  if (uniqueUsernames.length !== usernames.length) {\n    validation.errMsg = 'At least one username is duplicated';\n\n    return validation;\n  }\n\n  validation.correct = true;\n  return validation;\n};\n\nconst validateTimes = (times: string[]) => {\n  const positionNotTime: number[] = [];\n  const validation: Validation = {\n    correct: false,\n    errMsg: ''\n  };\n\n  times.forEach((time: string, index: number) => {\n    const timeIsValid = REGEX_TIME.test(time) || time === TIME_DNF;\n\n    if (!timeIsValid) {\n      positionNotTime.push(index + 1);\n    }\n  });\n\n  if (positionNotTime.length > 0) {\n    validation.errMsg = `The following positions have incorrect formatted times: ${positionNotTime.join(', ')}`;\n    return validation;\n  }\n\n  const minIndexTimeDnf = times.indexOf(TIME_DNF);\n  if (minIndexTimeDnf !== -1) {\n    const positionAfterDnf = [];\n\n    for (let i = minIndexTimeDnf + 1; i < times.length; i++) {\n      if (times[i] !== TIME_DNF) {\n        positionAfterDnf.push(i + 1);\n      }\n    }\n\n    if (positionAfterDnf.length > 0) {\n      validation.errMsg = `The following positions finished after somebody that did not finish: ${positionAfterDnf.join(\n        ', '\n      )}`;\n\n      return validation;\n    }\n  }\n\n  const finishedTimesLength = minIndexTimeDnf !== -1 ? minIndexTimeDnf : times.length;\n  const finishedTimes = times.slice(0, finishedTimesLength);\n  const finishedTimesMs = finishedTimes.map(convertToMs);\n  const copyMs = [...finishedTimesMs];\n  const sortedTimesMs = copyMs.sort((a: number, b: number) => {\n    return a - b;\n  });\n\n  if (finishedTimesMs.toString() !== sortedTimesMs.toString()) {\n    validation.errMsg = `From position 1 to position ${finishedTimesLength}, times are not in chronological order`;\n\n    return validation;\n  }\n\n  if (sortedTimesMs.length > 1) {\n    const maxTime = sortedTimesMs[sortedTimesMs.length - 1];\n    const minTime = sortedTimesMs[0];\n\n    const diffTime = maxTime - minTime;\n    if (diffTime > CTR_MAX_TIME_DIFF_SEC * 1000) {\n      validation.errMsg = `There are more than ${CTR_MAX_TIME_DIFF_SEC} seconds separating players`;\n\n      return validation;\n    }\n  }\n\n  validation.correct = true;\n  return validation;\n};\n\nexport {\n  applyRatio,\n  charRange,\n  cleanString,\n  convertToMs,\n  getCloserString,\n  getExtract,\n  getParams,\n  numberRange,\n  positionIsValid,\n  validateTimes,\n  validateUsernames\n};\n","import { charRange, numberRange } from './utils';\n\n// In the game CTR:NF, once player 1 finishes, online players have 30 seconds to complete the race\n// TODO: verify behavior in offline races\nexport const CTR_MAX_TIME_DIFF_SEC = 30;\nexport const CTR_MAX_PLAYERS = 8;\n\nexport const CHARLIST_UPPERCASE_LETTERS = charRange('A', 'Z').join('');\nexport const CHARLIST_LOWERCASE_LETTERS = charRange('a', 'z').join('');\nexport const CHARLIST_LETTERS = `${CHARLIST_LOWERCASE_LETTERS}${CHARLIST_UPPERCASE_LETTERS}`;\nexport const CHARLIST_DIGITS = numberRange(0, 9).join('');\nexport const CHARLIST_POSITION = numberRange(1, CTR_MAX_PLAYERS).join('');\nexport const CHARLIST_TIME = `${CHARLIST_DIGITS}:-`;\nexport const CHARLIST_USERNAME = `${CHARLIST_LETTERS}${CHARLIST_DIGITS}:-_. `;\nexport const MIME_JPEG = 'image/jpeg';\nexport const PSM_SINGLE_CHAR = '10';\nexport const PSM_SINGLE_LINE = '7';\nexport const SEPARATOR_PLAYERS = '\\n';\nexport const TIME_DNF = '--:--:--';\n","import * as React from 'react';\nimport './App.css';\nimport { Helmet, HelmetProvider } from 'react-helmet-async';\nimport { createWorker, createScheduler } from 'tesseract.js';\nimport { Category } from './types';\nimport getColors from 'get-image-colors';\nimport Jimp from 'jimp';\nimport useWindowSize from 'react-use/lib/useWindowSize';\nimport Confetti from 'react-confetti';\nimport { isMobile } from 'react-device-detect';\n\nimport { CTR_MAX_PLAYERS, MIME_JPEG, SEPARATOR_PLAYERS } from './constants';\nimport { cleanString, getCloserString, getExtract, getParams, numberRange } from './utils';\n\nconst language = 'eng';\n\nconst App = () => {\n  const renderDots = () => {\n    return <div className=\"dots\">{numberRange(1, 4).map(renderDot)}</div>;\n  };\n\n  const renderDot = (index: number) => {\n    const classColorPrefix = index === 4 ? 'green' : 'red';\n    const classColorSuffix = index > step ? '-off' : '';\n    const classColor = `${classColorPrefix}${classColorSuffix}`;\n    const classes = `dot ${classColor}`;\n    return <span key={index} className={classes}></span>;\n  };\n\n  const renderTable = () => {\n    return (\n      <table className=\"flex-1\">\n        <thead>\n          <tr>\n            <th>Position</th>\n            <th>Name</th>\n          </tr>\n        </thead>\n        {renderBody()}\n      </table>\n    );\n  };\n\n  const renderImages = () => {\n    if (isMobile)\n      return (\n        <>\n          <div className=\"img-show\"></div>\n          <img id=\"img-full\" alt={`Example ${imgIndex}`} src={src} />\n        </>\n      );\n\n    return (\n      <div className=\"flex-container center\">\n        <div className=\"flex-1\">\n          <img id=\"img-full\" alt={`Example ${imgIndex}`} src={src} />\n        </div>\n        <div className=\"img-show flex-1\"></div>\n      </div>\n    );\n  };\n\n  const renderBody = () => {\n    return (\n      <tbody>\n        {(resultsOcr as any).map((rawLine: any) => {\n          const { position, username, time } = rawLine;\n          const key = `${position}-${username}-${time}`;\n\n          return (\n            <tr key={key}>\n              <td>{position}</td>\n              <td>{username}</td>\n            </tr>\n          );\n        })}\n      </tbody>\n    );\n  };\n\n  const onMount = async () => {\n    // TODO: initialize?\n    setOnMountOver(true);\n    setSelectIsDisabled(false);\n  };\n\n  const doOCR = async () => {\n    if (!onMountOver) return;\n\n    setSelectIsDisabled(true);\n    setStep(0);\n    setResultsOcr(undefined);\n\n    const schedulerUsername = createScheduler();\n\n    const workerUsername = createWorker({\n      // logger: (m: any) => console.log(m)\n    });\n\n    schedulerUsername.addWorker(workerUsername);\n\n    const div = document.getElementsByClassName('img-show')[0];\n    if (div) div.innerHTML = '';\n\n    setStep(1);\n\n    setOcr('Loading engine... (1/4)');\n    await workerUsername.load();\n\n    setOcr('Loading language... (2/4)');\n    await workerUsername.loadLanguage(language);\n\n    setOcr('Initializing engine... (3/4)');\n    await workerUsername.initialize(language);\n\n    setOcr('Setting parameter... (4/4)');\n    const usernameParams = getParams(Category.Username);\n    await workerUsername.setParameters(usernameParams);\n\n    const playerIndexes = numberRange(0, nbPlayers - 1);\n\n    const promisesX = async (playerIndex: number, category: Category, info: any, imgTrans: any) => {\n      const imgTransCopy = imgTrans.clone();\n      const scheduler = schedulerUsername;\n      const dimensions = getExtract(info, playerIndex, category);\n\n      const extracted = imgTransCopy.crop(dimensions.left, dimensions.top, dimensions.width, dimensions.height);\n      const options = {\n        count: 2,\n        type: MIME_JPEG\n      };\n\n      const buffer: any = await extracted.getBufferAsync(MIME_JPEG);\n      const rgb = await getColors(buffer, options).then((colors: any) => {\n        return [colors[0].rgb(), colors[1].rgb()];\n      });\n\n      const shouldInvert = rgb[0][0] < rgb[1][0] && rgb[0][1] < rgb[1][1] && rgb[0][2] < rgb[1][2];\n      const extractedFin = shouldInvert ? extracted.invert() : extracted;\n\n      // TODO: activate for debugging only\n      // extractedFin.getBase64(MIME_JPEG, (err: any, src: string) => {\n      //   var img = document.createElement('img');\n      //   img.setAttribute('src', src);\n      //   const div = document.getElementsByClassName('img-show')[0];\n      //   if (div) div.appendChild(img);\n      // });\n\n      const bufferFin: any = await extractedFin.getBufferAsync(MIME_JPEG);\n      return scheduler.addJob('recognize', bufferFin);\n    };\n\n    const pathInput = `https://raw.githubusercontent.com/sebranly/ctr-ocr/main/src/img/input/IMG${imgIndex}.JPG`;\n    setStep(2);\n    setOcr('Reading the image...');\n    let imgTrans: any;\n    try {\n      const imgJimp = await Jimp.read(pathInput);\n\n      setOcr('Generating cropped image...');\n      imgTrans = imgJimp.rotate(-6.2);\n\n      const w = imgTrans.bitmap.width;\n      const h = imgTrans.bitmap.height;\n      const info = { width: w, height: h };\n      const dimensionsCrop = getExtract(info, nbPlayers, Category.All);\n\n      const imgTransCopy = imgTrans.clone();\n      const extractedCrop = imgTransCopy.crop(\n        dimensionsCrop.left,\n        dimensionsCrop.top,\n        dimensionsCrop.width,\n        dimensionsCrop.height\n      );\n\n      extractedCrop.getBase64(MIME_JPEG, (err: any, src: string) => {\n        var img = document.createElement('img');\n        img.setAttribute('src', src);\n        const div = document.getElementsByClassName('img-show')[0];\n        if (div) div.appendChild(img);\n      });\n\n      const promisesNames = playerIndexes.map((playerIndex) =>\n        promisesX(playerIndex, Category.Username, info, imgTrans.grayscale())\n      );\n\n      setOcr('Starting text recognition...');\n      setStep(3);\n      const results = await Promise.all(promisesNames);\n      const resultsNames = results.map((r) => cleanString((r as any).data.text));\n\n      const data: any = [];\n      const referencePlayers = players.split(SEPARATOR_PLAYERS);\n      playerIndexes.forEach((playerIndex) => {\n        const playerGuess = resultsNames[playerIndex];\n        const d = {\n          username: getCloserString(playerGuess, referencePlayers),\n          position: playerIndex + 1\n        };\n\n        data.push(d as any);\n      });\n\n      setResultsOcr(data);\n\n      setOcr('');\n      setStep(4);\n      setSelectIsDisabled(false);\n\n      await schedulerUsername.terminate();\n    } catch (err) {\n      setOcr(`Unable to open image ${(err as any).toString()}. Please restart.`);\n      setSelectIsDisabled(false);\n    }\n  };\n\n  const { width, height } = useWindowSize();\n  const [step, setStep] = React.useState(0);\n  const [ocr, setOcr] = React.useState('');\n  const [nbPlayers, setNbPlayers] = React.useState(CTR_MAX_PLAYERS);\n  const [selectIsDisabled, setSelectIsDisabled] = React.useState(true);\n  const [onMountOver, setOnMountOver] = React.useState(false);\n  const [imgIndex, setImgIndex] = React.useState(1);\n  const [resultsOcr, setResultsOcr] = React.useState(undefined);\n  const [players, setPlayers] = React.useState<string>('');\n\n  React.useEffect(() => {\n    onMount();\n  }, []);\n\n  const onPlayersChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setPlayers(e.currentTarget.value);\n  };\n\n  const onChangeNbPlayers = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setNbPlayers(Number(e.target.value));\n  };\n\n  const onChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setImgIndex(Number(e.target.value));\n  };\n\n  const src = `https://raw.githubusercontent.com/sebranly/ctr-ocr/main/src/img/input/IMG${imgIndex}.JPG`;\n  const options = [...numberRange(1, 5), ...numberRange(11, 20)];\n  const optionsNbPlayers = numberRange(2, CTR_MAX_PLAYERS);\n\n  const classPlatform = isMobile ? 'mobile' : 'desktop';\n\n  const textAreaPlaceholder = `Hyène_JurassX\nAlexiz\nColonel_Hay\nTATANE`;\n\n  return (\n    <HelmetProvider>\n      <Helmet>\n        <title>Crash Team Racing: OCR</title>\n        <link rel=\"canonical\" href=\"https://sebranly.github.io/ctr-ocr\" />\n      </Helmet>\n      <div className=\"main\">\n        <h1>Crash Team Racing: OCR</h1>\n        {step === 4 && <Confetti width={width} height={height} numberOfPieces={400} recycle={false} />}\n        <div className={`center main-content-${classPlatform}`}>\n          {renderDots()}\n          <div className=\"ocr\">{ocr}</div>\n          <h2>Players</h2>\n          <h3>Number of players</h3>\n          <select onChange={onChangeNbPlayers} value={nbPlayers}>\n            {optionsNbPlayers.map((option: number) => {\n              const label = `${option} players`;\n              return (\n                <option key={option} label={label} value={option}>\n                  {label}\n                </option>\n              );\n            })}\n          </select>\n          <h3>Name all players (one per line)</h3>\n          <textarea\n            className={`textarea-${classPlatform}`}\n            placeholder={textAreaPlaceholder}\n            rows={nbPlayers}\n            value={players}\n            onChange={onPlayersChange}\n          />\n          {!!resultsOcr && (\n            <div className=\"center\">\n              <h2>Results</h2>\n              <div className=\"flex-container results\">{renderTable()}</div>\n            </div>\n          )}\n          <h2>Image</h2>\n          <div className=\"center\">\n            <select disabled={selectIsDisabled} onChange={onChange}>\n              {options.map((option: number) => {\n                const label = `Image ${option}`;\n                return (\n                  <option key={option} label={label} value={option}>\n                    {label}\n                  </option>\n                );\n              })}\n            </select>\n            <input\n              className=\"inline ml\"\n              type=\"button\"\n              value=\"Start recognition\"\n              disabled={selectIsDisabled}\n              onClick={doOCR}\n            />\n          </div>\n          {renderImages()}\n        </div>\n      </div>\n    </HelmetProvider>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />,\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}